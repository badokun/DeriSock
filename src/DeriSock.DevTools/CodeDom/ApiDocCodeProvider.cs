namespace DeriSock.DevTools.CodeDom;

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;

using DeriSock.DevTools.ApiDoc.Model;
using DeriSock.Model;

using Microsoft.CSharp;

using Newtonsoft.Json;

internal class ApiDocCodeProvider
{
  private static readonly string[] GeneratedCodeComment =
  {
    "--------------------------------------------------------------------------",
    "<auto-generated>",
    "     This code was generated by a tool.",
    "",
    "     Changes to this file may cause incorrect behavior and will be lost if",
    "     the code is regenerated.",
    "</auto-generated>",
    "--------------------------------------------------------------------------"
  };

  private static readonly CodeAttributeDeclaration GeneratedCodeAttribute;
  private static readonly CodeAttributeDeclaration DebuggerNonUserCodeAttribute;
  private static readonly CodeAttributeDeclaration DebuggerBrowsableAttribute;
  private static readonly CodeAttributeDeclaration ObsoleteAttribute;

  private static readonly CodeTypeReference JsonPropertyAttributeType;
  private static readonly CodeTypeReference JsonConverterAttributeType;

  private static readonly CodeTypeReferenceExpression ArrayCodeTypeRefExpr;
  private static readonly CodeFieldReferenceExpression StringEmptyRefExpr;
  private static readonly CodeSnippetExpression NotNullValueRefExpr;

  private readonly CodeNamespace _namespace;
  private bool _hasConverters;
  private bool _hasJsonLinqEntities;

  public string FileExtension => ".cs";

  static ApiDocCodeProvider()
  {
    var asmName = typeof(ApiDocCodeProvider).Assembly.GetName();

    GeneratedCodeAttribute = new CodeAttributeDeclaration(
      new CodeTypeReference(typeof(GeneratedCodeAttribute)),
      new CodeAttributeArgument(new CodePrimitiveExpression(asmName.Name)),
      new CodeAttributeArgument(new CodePrimitiveExpression(asmName.Version?.ToString(3))));

    DebuggerNonUserCodeAttribute = new CodeAttributeDeclaration(new CodeTypeReference(typeof(DebuggerNonUserCodeAttribute)));

    DebuggerBrowsableAttribute = new CodeAttributeDeclaration(
      new CodeTypeReference(typeof(DebuggerBrowsableAttribute)),
      new CodeAttributeArgument(
        new CodeFieldReferenceExpression(
          new CodeTypeReferenceExpression(new CodeTypeReference(typeof(DebuggerBrowsableState))),
          nameof(DebuggerBrowsableState.Never))));

    ObsoleteAttribute = new CodeAttributeDeclaration(new CodeTypeReference(typeof(ObsoleteAttribute)));

    JsonPropertyAttributeType = new CodeTypeReference(typeof(JsonPropertyAttribute));
    JsonConverterAttributeType = new CodeTypeReference(typeof(JsonConverter));

    ArrayCodeTypeRefExpr = new CodeTypeReferenceExpression(typeof(Array));
    StringEmptyRefExpr = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(string)), nameof(string.Empty));
    NotNullValueRefExpr = new CodeSnippetExpression("null!");
  }

  public ApiDocCodeProvider(string @namespace = "DeriSock.Model")
  {
    _namespace = new CodeNamespace(@namespace);
  }

  public async Task<string> GenerateAsync()
  {
    CheckAndAddNeededImports();

    var options = new CodeGeneratorOptions
    {
      IndentString = "  ",
      BlankLinesBetweenMembers = true,

      //BracingStyle = "C",
      VerbatimOrder = true
    };

    var nullableStatement = new CodeSnippetStatement("#nullable enable");
    var disableMissingXmlCommentWarning = new CodeSnippetStatement("#pragma warning disable CS1591");

    var writer = new StringWriter();
    var provider = new CSharpCodeProvider();

    Array.ForEach(
      GeneratedCodeComment,
      line =>
        provider.GenerateCodeFromStatement(new CodeCommentStatement(line), writer, options));

    provider.GenerateCodeFromStatement(disableMissingXmlCommentWarning, writer, options);
    provider.GenerateCodeFromStatement(nullableStatement, writer, options);
    provider.GenerateCodeFromNamespace(_namespace, writer, options);

    await writer.FlushAsync();
    return writer.ToString();
  }

  private void CheckAndAddNeededImports()
  {
    if (_hasConverters) {
      _namespace.Imports.Add(new CodeNamespaceImport("System"));
      _namespace.Imports.Add(new CodeNamespaceImport("DeriSock.Converter"));
    }

    if (_hasJsonLinqEntities)
      _namespace.Imports.Add(new CodeNamespaceImport("Newtonsoft.Json.Linq"));
  }

  public void AddEnumValueClass(string typeName, ApiDocEnumMapEntry mapEntry)
  {
    var enumClass = new CodeTypeDeclaration(typeName)
    {
      Attributes = MemberAttributes.Public,
      IsPartial = true
    };

    enumClass.BaseTypes.Add(new CodeTypeReference(typeof(EnumValue)));

    enumClass.CustomAttributes.Add(GeneratedCodeAttribute);

    enumClass.Comments.Add(new CodeCommentStatement("<summary>", true));

    if (!string.IsNullOrEmpty(mapEntry.Description))
      foreach (var xmlDocParagraph in mapEntry.Description.ToXmlDocParagraphs())
        enumClass.Comments.Add(new CodeCommentStatement($"<para>{xmlDocParagraph}</para>", true));

    enumClass.Comments.Add(new CodeCommentStatement("</summary>", true));

    var thisEnumRef = new CodeTypeReference(typeName);

    foreach (var enumValue in mapEntry.EnumValues) {
      var fieldName = string.IsNullOrEmpty(enumValue) ? "None" : enumValue.ToPublicCodeName();

      var enumField = new CodeMemberField(thisEnumRef, fieldName);
      enumField.Attributes = (enumField.Attributes & ~MemberAttributes.AccessMask & ~MemberAttributes.ScopeMask) | MemberAttributes.Public | MemberAttributes.Static;
      enumField.InitExpression = new CodeObjectCreateExpression(thisEnumRef, new CodePrimitiveExpression(enumValue));
      enumClass.Members.Add(enumField);
    }

    var ctor = new CodeConstructor();
    ctor.Attributes = MemberAttributes.Private;
    ctor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(string), "value"));
    ctor.BaseConstructorArgs.Add(new CodeVariableReferenceExpression("value"));
    enumClass.Members.Add(ctor);

    _namespace.Types.Add(enumClass);
  }

  public void AddObjectValueClass(string typeName, ApiDocObjectMapEntry mapEntry)
  {
    var objClass = new CodeTypeDeclaration(typeName)
    {
      Attributes = MemberAttributes.Public,
      IsPartial = true
    };

    objClass.CustomAttributes.Add(GeneratedCodeAttribute);

    objClass.Comments.Add(new CodeCommentStatement("<summary>", true));

    if (!string.IsNullOrEmpty(mapEntry.Description))
      foreach (var xmlDocParagraph in mapEntry.Description.ToXmlDocParagraphs())
        objClass.Comments.Add(new CodeCommentStatement($"<para>{xmlDocParagraph}</para>", true));

    objClass.Comments.Add(new CodeCommentStatement("</summary>", true));

    var backingFieldCollection = new CodeTypeMemberCollection();
    var propertyCollection = new CodeTypeMemberCollection();

    foreach (var (_, value) in mapEntry.Properties) {
      var (backingField, property) = CreateProperty(value);
      backingFieldCollection.Add(backingField);
      propertyCollection.Add(property);
    }

    objClass.Members.AddRange(propertyCollection);
    objClass.Members.AddRange(backingFieldCollection);

    _namespace.Types.Add(objClass);
  }

  public void AddFunctionPropertyClass(string typeName, ApiDocProperty functionProperty)
  {
    if (functionProperty.Properties == null)
      return;

    var objClass = new CodeTypeDeclaration(typeName)
    {
      Attributes = MemberAttributes.Public,
      IsPartial = true
    };

    objClass.CustomAttributes.Add(GeneratedCodeAttribute);

    objClass.Comments.Add(new CodeCommentStatement("<summary>", true));

    if (!string.IsNullOrEmpty(functionProperty.Description))
      foreach (var xmlDocParagraph in functionProperty.Description.ToXmlDocParagraphs())
        objClass.Comments.Add(new CodeCommentStatement($"<para>{xmlDocParagraph}</para>", true));

    objClass.Comments.Add(new CodeCommentStatement("</summary>", true));

    var backingFieldCollection = new CodeTypeMemberCollection();
    var propertyCollection = new CodeTypeMemberCollection();

    foreach (var (_, value) in functionProperty.Properties) {
      var (backingField, property) = CreateProperty(value);
      backingFieldCollection.Add(backingField);
      propertyCollection.Add(property);
    }

    objClass.Members.AddRange(propertyCollection);
    objClass.Members.AddRange(backingFieldCollection);

    _namespace.Types.Add(objClass);
  }

  private (CodeMemberField backingField, CodeMemberProperty property) CreateProperty(ApiDocProperty property)
  {
    var dataTypeInfo = property.GetDataTypeInfo();

    var fullTypeName = dataTypeInfo.TypeName;

    if (dataTypeInfo.IsNullable && !dataTypeInfo.IsArray)
      fullTypeName = $"{fullTypeName}?";

    var propertyTypeReference = new CodeTypeReference(fullTypeName);

    var fieldName = property.Name;
    var propertyName = property.CodeName ?? property.Name.ToPublicCodeName();

    if (dataTypeInfo.IsArray)
      propertyTypeReference = new CodeTypeReference($"{fullTypeName}[]{(dataTypeInfo.IsNullable ? "?" : string.Empty)}");

    var memberField = CreateCodeMemberField(propertyTypeReference, $"_{propertyName}", dataTypeInfo.IsArray, dataTypeInfo.IsNullable);
    var memberProperty = CreateCodeMemberProperty(memberField, propertyName, fieldName, property.Description, property.Deprecated);

    if (property is { DataType: "JToken" or "JObject" })
      _hasJsonLinqEntities = true;

    if (property is { Converters.Length: > 0 }) {
      _hasConverters = true;

      foreach (var converterTypeName in property.Converters) {
        var jsonConverterAttribute = new CodeAttributeDeclaration(
          JsonConverterAttributeType,
          new CodeAttributeArgument(new CodeTypeOfExpression(converterTypeName)));

        memberProperty.CustomAttributes.Add(jsonConverterAttribute);
      }
    }

    return (memberField, memberProperty);
  }

  private void AddResultValueProperty(CodeTypeMemberCollection value, ApiDocProperty property)
  {
    var propertyTypeInfo = property.GetDataTypeInfo();
    var propertyTypeReference = new CodeTypeReference(propertyTypeInfo.TypeName);

    var fieldName = "result";
    var propertyName = "Value";

    if (propertyTypeInfo.IsArray)
      propertyTypeReference = new CodeTypeReference($"{propertyTypeInfo.TypeName}[]{(propertyTypeInfo.IsNullable ? "?" : string.Empty)}");
    else if (propertyTypeInfo.IsNullable)
      propertyTypeReference = new CodeTypeReference($"{propertyTypeInfo.TypeName}?");

    var memberField = CreateCodeMemberField(propertyTypeReference, $"_{propertyName}", propertyTypeInfo.IsArray, propertyTypeInfo.IsNullable);
    var memberProperty = CreateCodeMemberProperty(memberField, propertyName, fieldName, property.Description, false);

    if (property is { DataType: "JToken" or "JObject" })
      _hasJsonLinqEntities = true;

    if (property is { Converters.Length: > 0 }) {
      _hasConverters = true;

      foreach (var converterTypeName in property.Converters) {
        var jsonConverterAttribute = new CodeAttributeDeclaration(
          JsonConverterAttributeType,
          new CodeAttributeArgument(new CodeTypeOfExpression(converterTypeName)));

        memberProperty.CustomAttributes.Add(jsonConverterAttribute);
      }
    }

    value.Add(memberField);
    value.Add(memberProperty);
  }

  private static CodeMemberField CreateCodeMemberField(CodeTypeReference type, string name, bool isArray, bool isNullable)
  {
    var memberField = new CodeMemberField(type, name)
    {
      Attributes = MemberAttributes.Private
    };

    memberField.CustomAttributes.Add(DebuggerBrowsableAttribute);

    if (isNullable)
      return memberField;

    if (isArray) {
      memberField.InitExpression = new CodeFieldReferenceExpression(ArrayCodeTypeRefExpr, $"Empty<{type.BaseType}>()");
      return memberField;
    }

    var clrType = Type.GetType(type.BaseType);

    if (clrType is null) {
      if (type.BaseType == nameof(DateTime))
        return memberField;

      memberField.InitExpression = NotNullValueRefExpr;
      return memberField;
    }

    if (clrType == typeof(string)) {
      memberField.InitExpression = StringEmptyRefExpr;
      return memberField;
    }

    if (clrType.IsClass) {
      memberField.InitExpression = NotNullValueRefExpr;
      return memberField;
    }

    return memberField;
  }

  private static CodeMemberProperty CreateCodeMemberProperty(CodeMemberField memberField, string clrPropertyName, string jsonPropertyName, string? description, bool isDeprecated)
  {
    var memberProperty = new CodeMemberProperty
    {
      Name = clrPropertyName,
      Type = memberField.Type,

      // ReSharper disable once BitwiseOperatorOnEnumWithoutFlags
      Attributes = MemberAttributes.Public | MemberAttributes.Final
    };

    var memberFieldExpression = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), memberField.Name);
    memberProperty.GetStatements.Add(new CodeMethodReturnStatement(memberFieldExpression));
    memberProperty.SetStatements.Add(new CodeAssignStatement(memberFieldExpression, new CodePropertySetValueReferenceExpression()));

    // Add Attributes
    memberProperty.CustomAttributes.Add(DebuggerNonUserCodeAttribute);

    if (isDeprecated)
      memberProperty.CustomAttributes.Add(ObsoleteAttribute);

    memberProperty.CustomAttributes.Add(new CodeAttributeDeclaration(JsonPropertyAttributeType, new CodeAttributeArgument(new CodePrimitiveExpression(jsonPropertyName))));

    // Add Comments to the property
    memberProperty.Comments.Add(new CodeCommentStatement("<summary>", true));

    if (!string.IsNullOrEmpty(description))
      foreach (var xmlDocParagraph in description.ToXmlDocParagraphs())
        memberProperty.Comments.Add(new CodeCommentStatement($"<para>{xmlDocParagraph}</para>", true));

    memberProperty.Comments.Add(new CodeCommentStatement("</summary>", true));

    return memberProperty;
  }
}
