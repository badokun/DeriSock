namespace DeriSock.DevTools.CodeDom;

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

using DeriSock.DevTools.ApiDoc.Model;
using DeriSock.JsonRpc;
using DeriSock.Model;

using Microsoft.CSharp;

using Newtonsoft.Json;

internal class ApiDocCodeProvider
{
  private static readonly string[] GeneratedCodeComment =
  {
    "--------------------------------------------------------------------------",
    "<auto-generated>",
    "     This code was generated by a tool.",
    "",
    "     Changes to this file may cause incorrect behavior and will be lost if",
    "     the code is regenerated.",
    "</auto-generated>",
    "--------------------------------------------------------------------------"
  };

  private static readonly CodeAttributeDeclaration GeneratedCodeAttribute;
  private static readonly CodeAttributeDeclaration DebuggerNonUserCodeAttribute;
  private static readonly CodeAttributeDeclaration DebuggerBrowsableAttribute;
  private static readonly CodeAttributeDeclaration ObsoleteAttribute;

  private static readonly CodeTypeReference JsonPropertyAttributeType;
  private static readonly CodeTypeReference JsonConverterAttributeType;

  private static readonly CodeTypeReferenceExpression ArrayCodeTypeRefExpr;
  private static readonly CodeFieldReferenceExpression StringEmptyRefExpr;
  private static readonly CodeSnippetExpression NotNullValueRefExpr;

  private static readonly CodeNamespaceImport ImportSystem = new("System");
  private static readonly CodeNamespaceImport ImportSystemThreadingTasks = new("System.Threading.Tasks");
  private static readonly CodeNamespaceImport ImportDeriSockConverter = new("DeriSock.Converter");
  private static readonly CodeNamespaceImport ImportDeriSockJsonRpc = new("DeriSock.JsonRpc");
  private static readonly CodeNamespaceImport ImportDeriSockModel = new("DeriSock.Model");
  private static readonly CodeNamespaceImport ImportNewtonsoftJsonLinq = new("Newtonsoft.Json.Linq");

  private CodeNamespace _namespace;

  public string FileExtension => ".g.cs";

  static ApiDocCodeProvider()
  {
    var asmName = typeof(ApiDocCodeProvider).Assembly.GetName();

    GeneratedCodeAttribute = new CodeAttributeDeclaration(
      new CodeTypeReference(typeof(GeneratedCodeAttribute)),
      new CodeAttributeArgument(new CodePrimitiveExpression(asmName.Name)),
      new CodeAttributeArgument(new CodePrimitiveExpression(asmName.Version?.ToString(3))));

    DebuggerNonUserCodeAttribute = new CodeAttributeDeclaration(new CodeTypeReference(typeof(DebuggerNonUserCodeAttribute)));

    DebuggerBrowsableAttribute = new CodeAttributeDeclaration(
      new CodeTypeReference(typeof(DebuggerBrowsableAttribute)),
      new CodeAttributeArgument(
        new CodeFieldReferenceExpression(
          new CodeTypeReferenceExpression(new CodeTypeReference(typeof(DebuggerBrowsableState))),
          nameof(DebuggerBrowsableState.Never))));

    ObsoleteAttribute = new CodeAttributeDeclaration(new CodeTypeReference(typeof(ObsoleteAttribute)));

    JsonPropertyAttributeType = new CodeTypeReference(typeof(JsonPropertyAttribute));
    JsonConverterAttributeType = new CodeTypeReference(typeof(JsonConverter));

    ArrayCodeTypeRefExpr = new CodeTypeReferenceExpression(typeof(Array));
    StringEmptyRefExpr = new CodeFieldReferenceExpression(new CodeTypeReferenceExpression(typeof(string)), nameof(string.Empty));
    NotNullValueRefExpr = new CodeSnippetExpression("null!");
  }

  public ApiDocCodeProvider(string @namespace = "DeriSock.Model")
  {
    _namespace = new CodeNamespace(@namespace);
  }

  public async Task<string> GenerateAsync()
  {
    var options = new CodeGeneratorOptions
    {
      IndentString = "  ",
      BlankLinesBetweenMembers = true,

      //BracingStyle = "C",
      VerbatimOrder = true
    };

    var nullableStatement = new CodeSnippetStatement("#nullable enable");
    var disableMissingXmlCommentWarning = new CodeSnippetStatement("#pragma warning disable CS1591");

    var writer = new StringWriter();
    var provider = new CSharpCodeProvider();

    Array.ForEach(
      GeneratedCodeComment,
      line =>
        provider.GenerateCodeFromStatement(new CodeCommentStatement(line), writer, options));

    provider.GenerateCodeFromStatement(disableMissingXmlCommentWarning, writer, options);
    provider.GenerateCodeFromStatement(nullableStatement, writer, options);
    provider.GenerateCodeFromNamespace(_namespace, writer, options);

    await writer.FlushAsync();
    return writer.ToString();
  }

  public void Clear()
  {
    _namespace = new CodeNamespace(_namespace.Name);
  }

  public void AddEnumValueClass(string typeName, ApiDocEnumMapEntry mapEntry)
  {
    var enumClass = new CodeTypeDeclaration(typeName)
    {
      Attributes = MemberAttributes.Public,
      IsPartial = true
    };

    enumClass.BaseTypes.Add(new CodeTypeReference(typeof(EnumValue)));

    enumClass.CustomAttributes.Add(GeneratedCodeAttribute);

    enumClass.Comments.Add(new CodeCommentStatement("<summary>", true));

    if (!string.IsNullOrEmpty(mapEntry.Description))
      foreach (var xmlDocParagraph in mapEntry.Description.ToXmlDocParagraphs())
        enumClass.Comments.Add(new CodeCommentStatement($"<para>{xmlDocParagraph}</para>", true));

    enumClass.Comments.Add(new CodeCommentStatement("</summary>", true));

    var thisEnumRef = new CodeTypeReference(typeName);

    foreach (var enumValue in mapEntry.EnumValues) {
      var fieldName = string.IsNullOrEmpty(enumValue) ? "None" : enumValue.ToPublicCodeName();

      var enumField = new CodeMemberField(thisEnumRef, fieldName);
      enumField.Attributes = (enumField.Attributes & ~MemberAttributes.AccessMask & ~MemberAttributes.ScopeMask) | MemberAttributes.Public | MemberAttributes.Static;
      enumField.InitExpression = new CodeObjectCreateExpression(thisEnumRef, new CodePrimitiveExpression(enumValue));
      enumClass.Members.Add(enumField);
    }

    var ctor = new CodeConstructor();
    ctor.Attributes = MemberAttributes.Private;
    ctor.Parameters.Add(new CodeParameterDeclarationExpression(typeof(string), "value"));
    ctor.BaseConstructorArgs.Add(new CodeVariableReferenceExpression("value"));
    enumClass.Members.Add(ctor);

    _namespace.Types.Add(enumClass);
  }

  public void AddObjectValueClass(string typeName, ApiDocObjectMapEntry mapEntry)
  {
    var objClass = new CodeTypeDeclaration(typeName)
    {
      Attributes = MemberAttributes.Public,
      IsPartial = true
    };

    objClass.CustomAttributes.Add(GeneratedCodeAttribute);

    objClass.Comments.Add(new CodeCommentStatement("<summary>", true));

    if (!string.IsNullOrEmpty(mapEntry.Description))
      foreach (var xmlDocParagraph in mapEntry.Description.ToXmlDocParagraphs())
        objClass.Comments.Add(new CodeCommentStatement($"<para>{xmlDocParagraph}</para>", true));

    objClass.Comments.Add(new CodeCommentStatement("</summary>", true));

    var backingFieldCollection = new CodeTypeMemberCollection();
    var propertyCollection = new CodeTypeMemberCollection();

    foreach (var (_, value) in mapEntry.Properties) {
      var (backingField, property) = CreateProperty(value);
      backingFieldCollection.Add(backingField);
      propertyCollection.Add(property);
    }

    objClass.Members.AddRange(propertyCollection);
    objClass.Members.AddRange(backingFieldCollection);

    _namespace.Types.Add(objClass);
  }

  public void AddFunctionPropertyClass(string typeName, ApiDocProperty functionProperty)
  {
    if (functionProperty.Properties == null)
      return;

    var objClass = new CodeTypeDeclaration(typeName)
    {
      Attributes = MemberAttributes.Public,
      IsPartial = true
    };

    objClass.CustomAttributes.Add(GeneratedCodeAttribute);

    objClass.Comments.Add(new CodeCommentStatement("<summary>", true));

    if (!string.IsNullOrEmpty(functionProperty.Description))
      foreach (var xmlDocParagraph in functionProperty.Description.ToXmlDocParagraphs())
        objClass.Comments.Add(new CodeCommentStatement($"<para>{xmlDocParagraph}</para>", true));

    objClass.Comments.Add(new CodeCommentStatement("</summary>", true));

    var backingFieldCollection = new CodeTypeMemberCollection();
    var propertyCollection = new CodeTypeMemberCollection();

    foreach (var (_, value) in functionProperty.Properties) {
      var (backingField, property) = CreateProperty(value);
      backingFieldCollection.Add(backingField);
      propertyCollection.Add(property);
    }

    objClass.Members.AddRange(propertyCollection);
    objClass.Members.AddRange(backingFieldCollection);

    _namespace.Types.Add(objClass);
  }

  public void AddPartialInterface(string typeName, IEnumerable<ApiDocFunction> functions)
  {
    _namespace.Imports.Add(ImportSystemThreadingTasks);
    _namespace.Imports.Add(ImportDeriSockJsonRpc);
    _namespace.Imports.Add(ImportDeriSockModel);

    var objInterface = new CodeTypeDeclaration(typeName)
    {
      Attributes = MemberAttributes.Public,
      IsInterface = true,
      IsPartial = true
    };

    objInterface.CustomAttributes.Add(GeneratedCodeAttribute);

    foreach (var function in functions) {
      if (function.ExcludeInInterface)
        continue;

      var objMethod = new CodeMemberMethod
      {
        Attributes = MemberAttributes.Public | MemberAttributes.Final,
        Name = function.Name.ToPublicCodeName()
      };

      objMethod.CustomAttributes.Add(GeneratedCodeAttribute);

      objMethod.Comments.Add(new CodeCommentStatement("<summary>", true));

      if (!string.IsNullOrEmpty(function.Description))
        foreach (var xmlDocParagraph in function.Description.ToXmlDocParagraphs())
          objMethod.Comments.Add(new CodeCommentStatement($"<para>{xmlDocParagraph}</para>", true));

      objMethod.Comments.Add(new CodeCommentStatement("</summary>", true));

      var isVoid = true;
      var returnType = new CodeTypeReference(typeof(JsonRpcResponse<>));

      if (function.Response is { Properties.Count: > 0 }) {
        returnType.TypeArguments.Add($"{function.Name.ToPublicCodeName()}Response");
        isVoid = false;
      }
      else if (function.Response is not null) {
        var dataTypeInfo = function.Response.GetDataTypeInfo();

        if (dataTypeInfo is {TypeName: "DateTime"})
          _namespace.Imports.Add(ImportSystem);

        if (dataTypeInfo is {TypeName:"JToken" or "JObject"})
          _namespace.Imports.Add(ImportNewtonsoftJsonLinq);

        returnType.TypeArguments.Add(CreateCodeTypeReference(dataTypeInfo));
        isVoid = false;
      }

      if (isVoid) {
        if (!function.IsSynchronous)
          returnType = new CodeTypeReference(typeof(JsonRpcResponse));
      }
      else {
        if (function.IsSynchronous) {
          objMethod.ReturnType = returnType;
        }
        else {
          var realReturnType = new CodeTypeReference(typeof(Task<>));
          realReturnType.TypeArguments.Add(returnType);
          objMethod.ReturnType = realReturnType;
        }
      }

      if (function.Request is { Properties.Count: > 0 }) {
        var isRequired = function.Request.IsAnyPropertyRequired;
        objMethod.Parameters.Add(new CodeParameterDeclarationExpression($"{function.Name.ToPublicCodeName()}Request{(isRequired ? string.Empty : "?")}", "args"));
        objMethod.Comments.Add(new CodeCommentStatement("<param name=\"args\"></param>", true));
      }

      objInterface.Members.Add(objMethod);
    }

    _namespace.Types.Add(objInterface);
  }

  public void AddCategoriesInterface(string typeName, IEnumerable<string> names)
  {
    _namespace.Imports.Add(ImportSystemThreadingTasks);
    _namespace.Imports.Add(ImportDeriSockJsonRpc);
    _namespace.Imports.Add(ImportDeriSockModel);

    var objInterface = new CodeTypeDeclaration(typeName)
    {
      Attributes = MemberAttributes.Public,
      IsInterface = true,
      IsPartial = true
    };

    objInterface.CustomAttributes.Add(GeneratedCodeAttribute);

    foreach (var name in names) {
      var objMethod = new CodeMemberMethod
      {
        Attributes = MemberAttributes.Public | MemberAttributes.Final,
        Name = name.ToPublicCodeName()
      };

      var returnTypeName = $"I{objMethod.Name}Api";

      objMethod.CustomAttributes.Add(GeneratedCodeAttribute);

      objMethod.Comments.Add(new CodeCommentStatement($"<inheritdoc cref=\"{returnTypeName}\" />", true));

      objMethod.ReturnType = new CodeTypeReference(returnTypeName);

      objInterface.Members.Add(objMethod);
    }

    _namespace.Types.Add(objInterface);
  }

  private CodeTypeReference CreateCodeTypeReference(DataTypeInfo dataTypeInfo)
  {
    var fullTypeName = dataTypeInfo.TypeName;

    if (dataTypeInfo.IsNullable && !dataTypeInfo.IsArray)
      fullTypeName = $"{fullTypeName}?";

    if (dataTypeInfo.IsArray)
      fullTypeName = $"{fullTypeName}[]{(dataTypeInfo.IsNullable ? "?" : string.Empty)}";

    return new CodeTypeReference(fullTypeName);
  }

  private (CodeMemberField backingField, CodeMemberProperty property) CreateProperty(ApiDocProperty property)
  {
    var dataTypeInfo = property.GetDataTypeInfo();
    var propertyTypeReference = CreateCodeTypeReference(dataTypeInfo);

    var fieldName = property.Name;
    var propertyName = property.Name.ToPublicCodeName();


    var memberField = CreateCodeMemberField(propertyTypeReference, $"_{propertyName}", dataTypeInfo.IsArray, dataTypeInfo.IsNullable);
    var memberProperty = CreateCodeMemberProperty(memberField, propertyName, fieldName, property.Description, property.Deprecated);

    if (property is { DataType: "JToken" or "JObject" })
      _namespace.Imports.Add(ImportNewtonsoftJsonLinq);

    if (property is { Converters.Length: > 0 }) {
      _namespace.Imports.Add(ImportSystem);
      _namespace.Imports.Add(ImportDeriSockConverter);

      foreach (var converterTypeName in property.Converters) {
        var jsonConverterAttribute = new CodeAttributeDeclaration(
          JsonConverterAttributeType,
          new CodeAttributeArgument(new CodeTypeOfExpression(converterTypeName)));

        memberProperty.CustomAttributes.Add(jsonConverterAttribute);
      }
    }

    return (memberField, memberProperty);
  }

  private static CodeMemberField CreateCodeMemberField(CodeTypeReference type, string name, bool isArray, bool isNullable)
  {
    var memberField = new CodeMemberField(type, name)
    {
      Attributes = MemberAttributes.Private
    };

    memberField.CustomAttributes.Add(DebuggerBrowsableAttribute);

    if (isNullable)
      return memberField;

    if (isArray) {
      memberField.InitExpression = new CodeFieldReferenceExpression(ArrayCodeTypeRefExpr, $"Empty<{type.BaseType}>()");
      return memberField;
    }

    var clrType = Type.GetType(type.BaseType);

    if (clrType is null) {
      if (type.BaseType == nameof(DateTime))
        return memberField;

      memberField.InitExpression = NotNullValueRefExpr;
      return memberField;
    }

    if (clrType == typeof(string)) {
      memberField.InitExpression = StringEmptyRefExpr;
      return memberField;
    }

    if (clrType.IsClass) {
      memberField.InitExpression = NotNullValueRefExpr;
      return memberField;
    }

    return memberField;
  }

  private static CodeMemberProperty CreateCodeMemberProperty(CodeMemberField memberField, string clrPropertyName, string jsonPropertyName, string? description, bool isDeprecated)
  {
    var memberProperty = new CodeMemberProperty
    {
      Name = clrPropertyName,
      Type = memberField.Type,

      // ReSharper disable once BitwiseOperatorOnEnumWithoutFlags
      Attributes = MemberAttributes.Public | MemberAttributes.Final
    };

    var memberFieldExpression = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), memberField.Name);
    memberProperty.GetStatements.Add(new CodeMethodReturnStatement(memberFieldExpression));
    memberProperty.SetStatements.Add(new CodeAssignStatement(memberFieldExpression, new CodePropertySetValueReferenceExpression()));

    // Add Attributes
    memberProperty.CustomAttributes.Add(DebuggerNonUserCodeAttribute);

    if (isDeprecated)
      memberProperty.CustomAttributes.Add(ObsoleteAttribute);

    memberProperty.CustomAttributes.Add(new CodeAttributeDeclaration(JsonPropertyAttributeType, new CodeAttributeArgument(new CodePrimitiveExpression(jsonPropertyName))));

    // Add Comments to the property
    memberProperty.Comments.Add(new CodeCommentStatement("<summary>", true));

    if (!string.IsNullOrEmpty(description))
      foreach (var xmlDocParagraph in description.ToXmlDocParagraphs())
        memberProperty.Comments.Add(new CodeCommentStatement($"<para>{xmlDocParagraph}</para>", true));

    memberProperty.Comments.Add(new CodeCommentStatement("</summary>", true));

    return memberProperty;
  }
}
